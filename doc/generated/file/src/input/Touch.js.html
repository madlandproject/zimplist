<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/input/Touch.js | zimple</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="A zimple framework for building websites front-ends."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="zimple"><meta property="twitter:description" content="A zimple framework for building websites front-ends."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#core">core</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/core/EventTarget.js~EventTarget.html">EventTarget</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#display">display</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/display/BaseView.js~BaseView.html">BaseView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/display/ContainerView.js~ContainerView.html">ContainerView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/display/SplitText.js~SplitText.html">SplitText</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getDocumentRect">getDocumentRect</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#display-animation">display/animation</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/display/animation/SpriteAnimator.js~SpriteAnimator.html">SpriteAnimator</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#display-dom">display/dom</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-empty">empty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getScrollParent">getScrollParent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-index">index</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-removeClasses">removeClasses</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-stringToElement">stringToElement</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#geometry">geometry</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/geometry/Point.js~Point.html">Point</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#input">input</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/input/Keyboard.js~Keyboard.html">Keyboard</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/input/Mouse.js~Mouse.html">Mouse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/input/Touch.js~Touch.html">Touch</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#net">net</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/net/ImageLoader.js~ImageLoader.html">ImageLoader</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/net/Loader.js~Loader.html">Loader</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#utils">utils</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/Config.js~ConfigClass.html">ConfigClass</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/ScrollingTracker.js~Tracker.html">Tracker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/Ticker.js~Ticker.html">Ticker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/utils/WindowManager.js~WindowManagerClass.html">WindowManagerClass</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-AspectRatio">AspectRatio</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Style">Style</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/input/Touch.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import first from &apos;lodash/first&apos;;
import last from &apos;lodash/last&apos;;
import defaults from &apos;lodash/defaults&apos;;

import EventTarget from &apos;../core/EventTarget&apos;;

/**
 *
 * These constants represent gestures that the touch instance will try to match
 *
 *
 */
const GESTURES_DEFINITIONS = {

    /*

     SWIPE DETECTOR

     */
    &apos;swipe&apos;: {
        detect: function (events, options) {

            let detection = null;

            // only detect swipes with multiple events
            if (events.length &gt; 1) {
                let firstEvent = first(events);
                let lastEvent = last(events);

                // Swipe with one finger only.
                if (!isMultiTouch(firstEvent) &amp;&amp; !isMultiTouch(lastEvent)) {

                    let deltaX = lastEvent.touches[0].screenX - firstEvent.touches[0].screenX;
                    let deltaY = lastEvent.touches[0].screenY - firstEvent.touches[0].screenY;

                    let aDeltaX = Math.abs(deltaX);
                    let aDeltaY = Math.abs(deltaY);

                    // determine direction by comparison
                    if (aDeltaX &gt; (2 * aDeltaY) &amp;&amp; aDeltaX &gt; options.swipeThreshold) {

                        detection = {
                            axis: &apos;x&apos;,
                            distance: {
                                x: deltaX,
                                y: deltaY
                            }
                        }

                    } else if ( options.verticalSwipe &amp;&amp; aDeltaY &gt; (2 * aDeltaX)) {

                        detection = {
                            axis: &apos;y&apos;,
                            distance: {
                                x: deltaX,
                                y: deltaY
                            }
                        }

                    }

                }
            }

            return detection;
        },
        dispatchEvent(target, eventData) {

            // create event
            let swipeEvent = document.createEvent(&apos;CustomEvent&apos;);
            swipeEvent.initCustomEvent(&apos;swipe&apos;, true, false, null);
            swipeEvent.distance = eventData.distance;
            swipeEvent.axis = eventData.axis;

            // dispatch it through the DOM
            target.dispatchEvent(swipeEvent);

        },
        repeat: false
    },

    /*

     ZOOM DETECTOR

     */
    &apos;zoom&apos;: {
        detect: function (events) {
            let detection = null;

            // only detect zooms with multiple events
            if (events.length &gt;= 2) {

                let first = events[events.length - 2];
                let last = events[events.length - 1];

                // detect multiple multi touch events
                if (isMultiTouch(first) &amp;&amp; isMultiTouch(last)) {

                    // get distances for both points
                    let firstDistance = touchDistance(first);
                    let lastDistance = touchDistance(last);

                    // Zoom is onlt when fingers expand away from each other
                    if (firstDistance &lt; lastDistance ) {

                        return {
                            distance : lastDistance,
                            center : touchCenter(last)
                        }
                    }
                }
            }

            return detection;
        },
        dispatchEvent(target, eventData) {

            // create event
            let swipeEvent = document.createEvent(&apos;CustomEvent&apos;);
            swipeEvent.initCustomEvent(&apos;zoom&apos;, true, false, null);
            swipeEvent.distance = eventData.distance;

            // dispatch it through the DOM
            target.dispatchEvent(swipeEvent);

        },
        repeat: true
    },

    &apos;pinch&apos;: {
        detect: function (events) {
            let detection = null;

            // only detect zooms with multiple events
            if (events.length &gt;= 2) {

                let first = events[events.length - 2];
                let last = events[events.length - 1];

                // detect multiple multi touch events
                if (isMultiTouch(first) &amp;&amp; isMultiTouch(last)) {

                    // get distances for both points
                    let firstDistance = touchDistance(first);
                    let lastDistance = touchDistance(last);

                    if (firstDistance &gt; lastDistance ) {

                        return {
                            distance : lastDistance,
                            center : touchCenter(last)
                        }
                    }
                }
            }

            return detection;
        },
        dispatchEvent(target, eventData) {

            // create event
            let swipeEvent = document.createEvent(&apos;CustomEvent&apos;);
            swipeEvent.initCustomEvent(&apos;zoom&apos;, true, false, null);
            swipeEvent.distance = eventData.distance;

            // dispatch it through the DOM
            target.dispatchEvent(swipeEvent);

        },
        repeat: true
    }

};

/**
 * Determines if event is detecting mutliple touch points.
 * @param {TouchEvent} event - The TouchEvent to test
 * @returns {boolean}
 */
function isMultiTouch(event) {
    return event.touches.length &gt; 1;
}

/**
 * Get distance between two touches of an event. Simple square root.
 * @param {TouchEvent} event - A multi-touch native touch event
 * @returns {number} Distance in pixels between touches
 */
function touchDistance(event) {

    let a = event.touches[0];
    let b = event.touches[1];

    return Math.sqrt( Math.pow(b.clientX - a.clientX, 2) + Math.pow(b.clientY - a.clientY, 2) );
}

/**
 * Get center of touch event&apos;s touches.
 * @param {TouchEvent} event - The native event to analyse.
 * @return {{x: number, y: number}} The center the supplied event&apos;s touches. If there is a single touch, it will return it&apos;s coordinates.
 */
function touchCenter(event) {
    if ( isMultiTouch(event) ) {

        let a = event.touches[0];
        let b = event.touches[1];

        let aX = a.clientX;
        let aY = a.clientY;

        let bX = b.clientX;
        let bY = b.clientY;

        //         start
        let x = aX + ((bX - aX) / 2);
        let y = aY + ((bY - aY) / 2);

        return {
            x : x,
            y : y
        }

    } else {
        let touch = event.touches[0];

        return {
            x : touch.clientX,
            y : touch.clientY
        }
    }
}


/**
 * Class to track simple touch gestures. Inspired partly by hammer.js
 *
 * @TODO make gestures optional, moving detectors into separate class
 * @todo configure gesture detectors to avoid useless operations on multiple objects
 *
 */
class Touch extends EventTarget {

    /**
     * @param {Element} target - Target of touch events to listen to
     * @param {Object} options - Options for class behavior. See defaults for more info.
     */
    constructor(target, options = {}) {
        super();

        /**
         * Save event target
         * @type {Element}
         */
        this.target = target;

        /**
         * Saved options with default values.
         * @type {Object}
         */
        this.options = defaults(options, Touch.defaultOptions);

        // create and store bound functions that are used as event listeners
        this._touchEvents = {
            start: this._touchStartHandler.bind(this),
            move: this._touchMoveHandler.bind(this),
            end: this._touchEndHandler.bind(this)
        };

        this.target.addEventListener(&apos;touchstart&apos;, this._touchEvents.start);
        this.target.addEventListener(&apos;touchmove&apos;, this._touchEvents.move);
        this.target.addEventListener(&apos;touchend&apos;, this._touchEvents.end);

        // To help handling whole touch cycle (start -&gt; move -&gt; end) listen to the end event on the window too.
        if (this.options.bindWindowEnd) {
            window.addEventListener(&apos;touchend&apos;, this._touchEvents.end);
        }

    }

    /**
     * Get distance between first and last event points on both axis
     * @return {Number} Distance in pixels between first and last points currently tracked. Based on the first touch of a multi touch events
     */
    get distance() {

        // only return a number if there is a proper distance
        if ( !this._eventBuffer || this._eventBuffer.length &lt; 2 ) {
            return NaN;
        } else {

            let a = this._eventBuffer[0].touches[0];
            let b = this._eventBuffer[ this._eventBuffer.length - 1 ].touches[0];

            return Math.sqrt( Math.pow(b.clientX - a.clientX, 2) + Math.pow(b.clientY - a.clientY, 2) );
        }

    }


    /**
     * Get distance between first and last event points on the X axis
     * @return {Number} Distance in pixels between first and last points currently tracked. Based on the first touch of a multi touch events
     */
    get distanceX() {
        // only return a number if there is a proper distance
        if ( !this._eventBuffer || this._eventBuffer.length &lt; 2 ) {
            return NaN;
        } else {

            let a = this._eventBuffer[0].touches[0];
            let b = this._eventBuffer[ this._eventBuffer.length - 1  ].touches[0];

            return b.clientX - a.clientX;
        }
    }

    /**
     * Get distance between first and last event points on the Y axis
     * @return {Number} Distance in pixels between first and last points currently tracked. Based on the first touch of a multi touch events
     */
    get distanceY() {
        // only return a number if there is a proper distance
        if ( !this._eventBuffer || this._eventBuffer.length &lt; 2 ) {
            return NaN;
        } else {

            let a = this._eventBuffer[0].touches[0];
            let b = this._eventBuffer[ this._eventBuffer.length - 1  ].touches[0];

            return b.clientY - a.clientY;
        }
    }
    /**
     * Remove native events and cleanup
     */
    destroy() {

        this.target.removeEventListener(&apos;touchstart&apos;, this._touchEvents.start);
        this.target.removeEventListener(&apos;touchmove&apos;, this._touchEvents.move);
        this.target.removeEventListener(&apos;touchend&apos;, this._touchEvents.end);

        if (this.options.bindWindowEnd) {
            window.removeEventListener(&apos;touchend&apos;, this._touchEvents.end);
        }

    }

    /* =======

     Private methods

     ======== */

    /**
     * Start tracking touch events on the target element.
     *
     * @param {TouchEvent} event - Native DOM event
     * @emits {TouchEvent} Native DOM event
     * @private
     */
    _start(event) {

        // in case &apos;end()&apos; isn&apos;t called properly. Probably shouldn&apos;t happen.
        if (this.isTouched) this.end();

        /**
         * flag to indicate if there is acutally a touch on the device.
         * @type {boolean}
         */
        this.isTouched = true;

        /**
         * Internal buffer of events to analyse
         * @type {TouchEvent[]}
         * @private
         */
        this._eventBuffer = [event];

        /**
         * Internal list of gestures currently being detected
         * @type {{}}
         * @private
         */
        this._currentGestures = {};

        this.trigger(&apos;start&apos;, event);
    }

    /**
     *
     * @param {TouchEvent} event - Native DOM event
     * @private
     */
    _move(event) {
        this._eventBuffer.push(event);

        // Run detectors
        // TODO move to sub-class
        for (let gesture in GESTURES_DEFINITIONS) {

            let gestureDef = GESTURES_DEFINITIONS[gesture];
            let gestureInfo = gestureDef.detect(this._eventBuffer, this.options);

            // if gesture detected
            if (gestureInfo) {

                // prevent repeat events on gestures that only should happen once per touch cycle (swipe for example). Could also be handled in touchend?
                if ( gestureDef.repeat || (!gestureDef.repeat &amp;&amp; !this._currentGestures[gesture]) ) {

                    // attempt to prevent default
                    event.preventDefault();

                    // save gesture
                    this._currentGestures[gesture] = gestureInfo;

                    if (this.options.domEvents) {
                        gestureDef.dispatchEvent(this.target, gestureInfo);
                    }

                    this.trigger(gesture, gestureInfo);
                }

            }
        }


        this.trigger(&apos;move&apos;, event);

    }

    /**
     * End of touch. Reset internal vars
     * @param event - Native DOM event
     * @emits {TouchEvent} - Native DOM event
     * @private
     */
    _end(event) {

        // Trigger event before disposing of saved state
        this.trigger(&apos;end&apos;, event);

        this._eventBuffer = [];
        this.isTouched = false;

    }

    /* =======

     Event Handlers

     ======== */

    /**
     * Native start event handler
     * @param event
     * @private
     */
    _touchStartHandler(event) {

        // standard behviour is too disable scrolling and zooming on multi touch
        if (event.touches.length &gt; 1) {
            event.preventDefault();
        }

        // if we&apos;re already touching, and another finger starts touching, treat it as a move
        if (this.isTouched) {
            this._move(event);
        } else {
            this._start(event);
        }

    }

    /**
     * Native move event handler
     * @param event
     * @private
     */
    _touchMoveHandler(event) {

        // standard behviour is too disable scrolling and zooming on multi touch
        if (event.touches.length &gt; 1) {
            event.preventDefault();
        }

        this._move(event);
    }

    /**
     * Native end event handker
     * @param event
     * @private
     */
    _touchEndHandler(event) {
        this._end(event);
    }

}

/**
 * @static
 * @type {{verticalSwipe: boolean, swipeThreshold: number, domEvents: boolean}}
 */
Touch.defaultOptions = {

    /**
     * Dected y axis when detecting swipes. Very often we don&apos;t want to block scrolling.
     */
    verticalSwipe: false,

    /**
     * Minimum distance to trigger swipe event
     */
    swipeThreshold: 10,

    /**
     * Will create and trigger custom bubbling DOM events for gestures.
     */
    domEvents: true

};

export default Touch</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
