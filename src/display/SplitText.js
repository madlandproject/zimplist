import _ from "lodash";

class SplitText {

    constructor(el, options = {}) {

        this.el = el;

        _.defaults(options, SplitText.defaultOptions);

        // Save filter functions
        this.wordFilter = options.wordFilter;
        this.charFilter = options.charFilter;

        this.lineClass = options.lineClass;
        this.wordClass = options.wordClass;
        this.charClass = options.charClass;

        // Save a string representation of the elements original
        this._originalHTML = this.el.innerHTML;

        // Parse the contents of the element
        this.parsedNodes = this._parseNodeContent( this.el );

        this.el.classList.add('split-text');
        this.el.innerHTML = this._renderString();

    }


    /**
     * Remove elements generated by text splitting process and re-inject original contents
     */
    reset() {
        this.el.innerHTML = this._originalHTML;
        this.el.classList.remove('split-text');
    }


    /*


     PRIVATE METHODS


     */

    /**
     * Return the composed HTML of split text
     * @returns {String}
     * @private
     */
     _renderString() {

        // TODO use native reduce
        var render = _.reduce( this.parsedNodes, (rendered, currentItem)=>{
            let nodeHTML;
            if ( _.isArray(currentItem) ) {
                nodeHTML = this._createWord(currentItem).outerHTML+" "; // MUST include a space after the word or all the words will be treated as one long word
            } else if ( _.isElement(currentItem) ) {

                if (currentItem.tagName.toLowerCase() == 'br') { // If it's a BR, start a new line
                    nodeHTML = `</div><div class="${this.lineClass}">`
                } else {
                    nodeHTML = currentItem.outerHTML;
                }

            }
            return rendered + nodeHTML;
        }, `<div class="${this.lineClass}">`); // start reduce with a new .line element

        // Close line
        render += "</div>";

        return render;

    }

    /**
     *
     *
     * @param content {String} single char to create an element for
     * @returns {DOMElement} element representing a single character
     * @private
     */
    _createChar(content) {
        var char = document.createElement('span');
        char.className = this.charClass;
        char.textContent = content;
        return this.charFilter(char);
    }

    /**
     * Returns a span containing multiple characters
     *
     * @param charArray {Array} Array of characters
     * @returns {DOMElement} an element containing multiple char elements
     * @private
     */
    _createWord(charArray) {
        var word = document.createElement('span');
        word.className = this.wordClass;
        // set the whole HTML of the word by mapping each char to a div, and reducting them to a string;
        word.innerHTML = charArray.map( (char) => this._createChar(char) ).reduce( (fullWord, char) => fullWord + char.outerHTML, '');
        return this.wordFilter( word );
    }

    /**
     * Loop over element returning an array of elements and words. Each word is an array of chars.
     *
     * @param el
     * @returns {Array}
     */
    _parseNodeContent(el) {
        var children = el.childNodes;
        var parsedNodes = [];

        for (let i = 0; i < children.length; i++ ) {
            let node = children[i];

            if (node.nodeType == 1) { // node is Element

                parsedNodes.push( node ); // TODO handle recursion if node has child nodes

            } else if (node.nodeType == 3) { // node is text node

                // trim off excess white space
                let nodeValue = _.trim( node.nodeValue );

                // don't parse empty nodes
                if (nodeValue.length > 0) {
                    // split a text node into specific words
                    let words = nodeValue.split(/\s/);

                    // for each word, add an array of it's character
                    words.forEach( (word) => {
                        parsedNodes.push( word.split('') );
                    });
                }
            }
        }

        return parsedNodes;
    }

}

SplitText.defaultOptions = {
    wordFilter: _.identity,
    charFilter: _.identity, // TODO use internal function ?
    lineClass : 'line',
    wordClass: 'word',
    charClass: 'char'
};


export default SplitText;


/*

TODO move this to docs

Internal representation

[
    [
        'l',
        'a'
    ],
    <br />,
    [
        'R',
        'Ã©',
        'p',
        'u',
        'b',
        'l',
        'i',
        'q',
        'u',
        'e'
    ],
    <br />,
    [
        'd',
        'u'
    ],
    [
        'v',
        'e',
        'n',
        't'
    ]
]


 */
